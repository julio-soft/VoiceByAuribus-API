name: Deploy to Production

on:
  push:
    branches:
      - main
      - test
    paths:
      # Only trigger deployment when VoiceByAuribus.API files change
      - 'VoiceByAuribus.API/**'
      - '.github/workflows/deploy-production.yml'
      - '.github/workflows/build-and-push.yml'
      - 'VoiceByAuribus-API.sln'
      - 'Dockerfile'
      - 'global.json'
  workflow_dispatch:  # Allow manual triggering from GitHub UI

# Prevent concurrent deployments to avoid migration lock conflicts
concurrency:
  group: ${{ github.ref }}-deployment
  cancel-in-progress: false  # Wait for previous deployment to finish

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: voice-by-auribus-api
  PROJECT_NAME: voice-by-auribus-api

jobs:
  # ==============================================================================
  # JOB 1: APLICAR MIGRACIONES
  # ==============================================================================
  migrate:
    name: Apply Database Migrations
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup .NET 10
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Set Environment Variables
        run: |
          echo "ðŸ” Detectando ambiente basado en rama: ${{ github.ref }}"
          
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "ASPNETCORE_ENVIRONMENT=Production" >> $GITHUB_ENV
            echo "SECRET_NAME=voice-by-auribus-api/production" >> $GITHUB_ENV
            echo "âœ… Environment: Production"
          elif [ "${{ github.ref }}" == "refs/heads/test" ]; then
            echo "ASPNETCORE_ENVIRONMENT=Staging" >> $GITHUB_ENV
            echo "SECRET_NAME=voice-by-auribus-api/staging" >> $GITHUB_ENV
            echo "âœ… Environment: Staging"
          else
            echo "âŒ ERROR: Este workflow solo debe ejecutarse desde rama 'main' o 'test'"
            echo "Rama actual: ${{ github.ref }}"
            echo "Para evitar migraciones no deseadas en producciÃ³n, el workflow se cancela"
            exit 1
          fi
      
      - name: Validate Environment Configuration
        run: |
          echo "ðŸ”’ Validando configuraciÃ³n de ambiente..."
          echo "Rama: ${{ github.ref }}"
          echo "Environment: ${{ env.ASPNETCORE_ENVIRONMENT }}"
          echo "Secret: ${{ env.SECRET_NAME }}"
          
          # ValidaciÃ³n adicional de seguridad
          if [ "${{ github.ref }}" == "refs/heads/main" ] && [ "${{ env.ASPNETCORE_ENVIRONMENT }}" != "Production" ]; then
            echo "âŒ ERROR DE SEGURIDAD: Rama main debe usar Production environment"
            exit 1
          fi
          
          if [ "${{ github.ref }}" == "refs/heads/test" ] && [ "${{ env.ASPNETCORE_ENVIRONMENT }}" != "Staging" ]; then
            echo "âŒ ERROR DE SEGURIDAD: Rama test debe usar Staging environment"
            exit 1
          fi
          
          echo "âœ… ConfiguraciÃ³n de ambiente validada correctamente"
      
      - name: Get Database Connection from Secrets Manager
        id: get-db-connection
        run: |
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "${{ env.SECRET_NAME }}" \
            --region ${{ env.AWS_REGION }} \
            --query 'SecretString' \
            --output text)
          
          # Extraer ConnectionString del JSON
          DB_CONNECTION=$(echo "$SECRET_JSON" | jq -r '.ConnectionStrings__DefaultConnection')
          
          # Verificar que no estÃ© vacÃ­o
          if [ -z "$DB_CONNECTION" ] || [ "$DB_CONNECTION" == "null" ]; then
            echo "âŒ Error: No se pudo obtener la connection string"
            exit 1
          fi
          
          echo "âœ… Connection string obtenida exitosamente desde ${{ env.SECRET_NAME }}"
          # Guardar en variable de entorno (masked en logs)
          echo "::add-mask::$DB_CONNECTION"
          echo "DB_CONNECTION=$DB_CONNECTION" >> $GITHUB_ENV
      
      - name: Install EF Core Tools
        run: |
          dotnet tool install --global dotnet-ef
          echo "$HOME/.dotnet/tools" >> $GITHUB_PATH
      
      - name: Restore and Build
        run: |
          echo "ðŸ“¦ Restaurando paquetes NuGet y compilando proyecto..."
          dotnet restore VoiceByAuribus.API/VoiceByAuribus-API.csproj
          dotnet build VoiceByAuribus.API/VoiceByAuribus-API.csproj --no-restore --configuration Release

      - name: Check Pending Migrations
        id: check-migrations
        run: |
          echo "ðŸ” Verificando si hay migraciones pendientes..."
          
          # Obtener lista de migraciones en el cÃ³digo
          echo "ðŸ“‹ Migraciones en el cÃ³digo:"
          CODE_MIGRATIONS=$(dotnet ef migrations list \
            --no-build \
            --no-connect \
            --project VoiceByAuribus.API/VoiceByAuribus-API.csproj 2>&1)
          
          echo "$CODE_MIGRATIONS"
          CODE_COUNT=$(echo "$CODE_MIGRATIONS" | grep -E '^[0-9]{14}_' | wc -l | tr -d ' ')
          
          echo ""
          echo "ðŸ”— Consultando base de datos..."
          echo "   Migraciones en cÃ³digo: $CODE_COUNT"
          
          # Ejecutar database update directamente
          # EF Core es idempotente - si no hay pendientes, no hace nada
          echo ""
          echo "Ejecutando: dotnet ef database update..."
          UPDATE_OUTPUT=$(dotnet ef database update \
            --no-build \
            --verbose \
            --project VoiceByAuribus.API/VoiceByAuribus-API.csproj \
            --connection "${{ env.DB_CONNECTION }};Command Timeout=60" 2>&1 || echo "UPDATE_FAILED")
          
          echo "$UPDATE_OUTPUT"
          
          # Analizar output para detectar si aplicÃ³ migraciones
          # EF Core muestra "Applying migration" cuando aplica algo
          # O "No migrations were applied" / "database is already up to date"
          if echo "$UPDATE_OUTPUT" | grep -qi "Applying migration\|Executed DbCommand"; then
            # AplicÃ³ migraciones - significa que SÃ habÃ­a pendientes
            echo ""
            echo "âš ï¸  DETECTADAS Y APLICADAS migraciones pendientes"
            echo "HAS_PENDING=true" >> $GITHUB_OUTPUT
            
            # Contar cuÃ¡ntas aplicÃ³
            APPLIED=$(echo "$UPDATE_OUTPUT" | grep -c "Applying migration" || echo "unknown")
            echo "   Migraciones aplicadas: $APPLIED"
          elif echo "$UPDATE_OUTPUT" | grep -qi "No migrations were applied\|already.*up.*to.*date\|No pending model changes"; then
            # No aplicÃ³ nada - BD actualizada
            echo ""
            echo "âœ… No hay migraciones pendientes - la base de datos estÃ¡ actualizada"
            echo "HAS_PENDING=false" >> $GITHUB_OUTPUT
          elif echo "$UPDATE_OUTPUT" | grep -qi "UPDATE_FAILED\|error\|exception"; then
            # Hubo error - ser conservador y asumir que hay pendientes
            echo ""
            echo "âŒ Error al verificar migraciones - se asumirÃ¡ que hay pendientes"
            echo "HAS_PENDING=true" >> $GITHUB_OUTPUT
          else
            # Output no claro - ser conservador
            echo ""
            echo "âš ï¸  No se pudo determinar el estado - se asumirÃ¡ que hay pendientes"
            echo "HAS_PENDING=true" >> $GITHUB_OUTPUT
          fi

      - name: Verify Migrations Applied
        if: steps.check-migrations.outputs.HAS_PENDING == 'true'
        run: |
          echo "âœ… Migraciones verificadas y aplicadas en el paso anterior"
          echo "   El comando 'database update' ya aplicÃ³ los cambios necesarios"

      - name: Skip Migrations (Already Applied)
        if: steps.check-migrations.outputs.HAS_PENDING == 'false'
        run: |
          echo "â„¹ï¸  No hay migraciones para aplicar. Continuando con el deployment..."
  
  # ==============================================================================
  # JOB 2: BUILD & PUSH (reutiliza workflow existente)
  # ==============================================================================
  build-and-push:
    name: Build and Push Docker Image
    needs: migrate  # Solo se ejecuta si migrate fue exitoso
    uses: ./.github/workflows/build-and-push.yml
    secrets: inherit  # Hereda todos los secrets
  
  # ==============================================================================
  # JOB 3: DEPLOY A APP RUNNER
  # ==============================================================================
  deploy:
    name: Deploy to App Runner
    runs-on: ubuntu-latest
    needs: build-and-push  # Solo se ejecuta si build-and-push fue exitoso
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get App Runner Service ARN
        id: get-service-arn
        run: |
          SERVICE_ARN=$(aws apprunner list-services \
            --region ${{ env.AWS_REGION }} \
            --query "ServiceSummaryList[?ServiceName=='${{ env.PROJECT_NAME }}'].ServiceArn" \
            --output text)
          
          if [ -z "$SERVICE_ARN" ]; then
            echo "âŒ Error: No se encontrÃ³ el servicio App Runner '${{ env.PROJECT_NAME }}'"
            exit 1
          fi
          
          echo "SERVICE_ARN=$SERVICE_ARN" >> $GITHUB_ENV
          echo "âœ… App Runner Service: $SERVICE_ARN"
          echo "â„¹ï¸  App Runner auto-deployment triggered by :latest tag push"
      
      - name: Wait for Auto-Deployment
        run: |
          echo "â³ Waiting for App Runner auto-deployment to complete..."
          echo "â„¹ï¸  Auto-deployment triggered by :latest tag detection"
          echo ""
          
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          # Wait a bit for auto-deployment to start
          sleep 15
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATUS=$(aws apprunner describe-service \
              --service-arn ${{ env.SERVICE_ARN }} \
              --region ${{ env.AWS_REGION }} \
              --query 'Service.Status' \
              --output text)
            
            echo "Status: $STATUS (attempt $ATTEMPT/$MAX_ATTEMPTS)"
            
            if [ "$STATUS" == "RUNNING" ]; then
              echo "âœ… Auto-deployment completed successfully"
              break
            elif [ "$STATUS" == "OPERATION_IN_PROGRESS" ]; then
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
            else
              echo "âŒ Deployment failed with status: $STATUS"
              exit 1
            fi
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "âŒ Timeout waiting for auto-deployment"
            exit 1
          fi
      
      - name: Get Service URL
        id: get-url
        run: |
          SERVICE_URL=$(aws apprunner describe-service \
            --service-arn ${{ env.SERVICE_ARN }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Service.ServiceUrl' \
            --output text)
          
          echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
          echo "ðŸŒ Service URL: https://$SERVICE_URL"
      
      - name: Verify Health Endpoint
        run: |
          echo "ðŸ¥ Verificando health endpoint..."
          sleep 10  # Dar tiempo a que el servicio estÃ© listo
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://${{ env.SERVICE_URL }}/api/v1/health")
          
          if [ "$HTTP_CODE" == "200" ]; then
            echo "âœ… Health check: OK (200)"
          else
            echo "âš ï¸ Health check retornÃ³: $HTTP_CODE (esperado: 200)"
            echo "El servicio puede estar aÃºn inicializando"
          fi
      
      - name: Deployment Summary
        if: success()
        run: |
          echo "=========================================="
          echo "âœ… DEPLOYMENT EXITOSO"
          echo "=========================================="
          echo "Imagen: ${{ needs.build-and-push.outputs.image-uri }}"
          echo "Tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "Service URL: https://${{ env.SERVICE_URL }}"
          echo ""
          echo "Endpoints:"
          echo "  - Health: https://${{ env.SERVICE_URL }}/api/v1/health"
          echo ""
          echo "Monitoreo:"
          echo "  - CloudWatch: https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}"
          echo "  - App Runner: https://console.aws.amazon.com/apprunner/home?region=${{ env.AWS_REGION }}"
          echo "=========================================="

# ==============================================================================
# CONFIGURACIÃ“N DE SECRETS REQUERIDOS EN GITHUB
# ==============================================================================
# Ir a: Settings > Secrets and variables > Actions > New repository secret
#
# Secrets requeridos:
# - AWS_ACCESS_KEY_ID: Access key de IAM user con permisos de:
#   * SecretsManager:GetSecretValue
#   * ECR:GetAuthorizationToken, BatchCheckLayerAvailability, InitiateLayerUpload, etc.
#   * AppRunner:StartDeployment, DescribeService, ListServices
#
# - AWS_SECRET_ACCESS_KEY: Secret key correspondiente
#
# - (Opcional) SLACK_WEBHOOK_URL: Para notificaciones de deployment
# ==============================================================================
